#!/usr/bin/env python

"""
Simple websocket server which allows clients to subscribe to real time stock
updates.

A collector for a given stock is represented as a green thread. Every
second collectors will poll for an update to broadcast to its output pipe.

A keep-alive http connection is held open to nasqaq.com and all collectors
multiplex over this single connection.

Any number of websocket clients can subscribe to the same stock and will be
sent updates when its collector pulls a fresh value.
"""

"""
TODO:

- keep a worker around for a short bit of the last listener drops off, so
  they're hot if the listener reconnects

- fix crashes:

    - if a websocket closes unexpectedly on read
    - if the conn used to the http scrape closes

- profile cpu usage
"""

import logging
import json
import sys
import os
import re

import lxml.html

import vanilla


class Collector(object):
    def __init__(self, hub, conn, symbol):
        self.hub = hub
        self.conn = conn
        self.symbol = symbol
        self.output = hub.broadcast()
        hub.spawn(self.collect)

    def collect(self):
        USER_AGENT = 'Mozilla/5.0 (Windows NT 6.3; ' \
                     'Win64; x64) AppleWebKit/537.36 ' \
                     '(KHTML, like Gecko) Chrome/37.0.2049.0 Safari/537.36'

        headers = {'User-Agent': USER_AGENT}

        for _ in self.hub.pulse(1000):
            response = self.conn.get(
                '/symbol/%s/real-time' % self.symbol.lower(),
                headers=headers).recv()

            body = response.consume()
            tree = lxml.html.document_fromstring(body)

            data = {
                'symbol': self.symbol.upper(),
                'quote': tree.xpath('//div[@id="qwidget_lastsale"]')[0].text,
                'change': tree.xpath('//div[@id="qwidget_netchange"]')[0].text,
                'percent': tree.xpath('//div[@id="qwidget_percent"]')[0].text,
                'when':
                    tree.xpath(
                        '//div[@id="qwidget_markettimedate"]//span')[0].text,
                'up':
                    'arrow-green' in
                    tree.xpath(
                        '//div[@id="qwidget-arrow"]/div')[0].get('class'), }

            if len(data['when']) < 11:
                data['when'] += ' - market closed'

            print data['symbol'], data['quote']
            self.data = data
            self.output.send(data)


class Feed(object):
    def __init__(self, hub):
        self.hub = hub
        # share a common keep-alive connection for all collectors
        self.conn = self.hub.http.connect('http://www.nasdaq.com/')
        self.collectors = {}

    def subscribe(self, symbol):
        if symbol not in self.collectors:
            print "BOOTING", symbol
            # there's not a collector for this symbol yet, so let's boot one
            self.collectors[symbol] = Collector(self.hub, self.conn, symbol)
        return self.collectors[symbol].output.subscribe()


def main():
    logging.basicConfig(level=logging.DEBUG)

    print 'start'
    h = vanilla.Hub()

    feed = Feed(h)

    app = h.bean(
        host='0.0.0.0',
        port=8000,
        base_path=os.path.join(os.path.dirname(__file__)))

    app.static('/', 'index.html')

    pattern = re.compile('^[a-zA-Z]{1,5}$')

    @app.websocket('/')
    def index(ws):
        watch = [ws.recver]

        # watch for updates from the client (requests for new subscriptions)
        # and to subscribed stocks
        while True:
            try:
                ch, data = h.select(watch)
            except vanilla.Halt:
                return

            if ch == ws.recver:
                # request to subscribe to a new stock
                if pattern.match(data):
                    watch.append(feed.subscribe(data))
            else:
                # price update, forward it on the client
                ws.send(json.dumps(data))

    h.stop_on_term()
    print 'peace.'


if __name__ == '__main__':
    sys.exit(main())
